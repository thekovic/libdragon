<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libdragon: DMA Controller</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo2.png"/></td>
  <td id="projectalign">
   <div id="projectname">libdragon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">DMA Controller<div class="ingroups"><a class="el" href="group__libdragon.html">libdragon</a> &raquo; <a class="el" href="group__lowlevel.html">Low Level Hardware Interfaces</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>DMA functionality for transfers between cartridge space and RDRAM.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:dma_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8c.html">dma.c</a></td></tr>
<tr class="memdesc:dma_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMA Controller. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dma_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html">dma.h</a></td></tr>
<tr class="memdesc:dma_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMA Controller. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa18917e3e33e3a61f7ce5632e8cc15eb"><td class="memItemLeft" align="right" valign="top"><a id="gaa18917e3e33e3a61f7ce5632e8cc15eb" name="gaa18917e3e33e3a61f7ce5632e8cc15eb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PI_DRAM_ADDR</b>&#160;&#160;&#160;((volatile uint32_t*)0xA4600000)</td></tr>
<tr class="memdesc:gaa18917e3e33e3a61f7ce5632e8cc15eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">PI DMA: DRAM address register. <br /></td></tr>
<tr class="separator:gaa18917e3e33e3a61f7ce5632e8cc15eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cd13d43fe8799f8d51a61c8126ef2fc"><td class="memItemLeft" align="right" valign="top"><a id="ga6cd13d43fe8799f8d51a61c8126ef2fc" name="ga6cd13d43fe8799f8d51a61c8126ef2fc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PI_CART_ADDR</b>&#160;&#160;&#160;((volatile uint32_t*)0xA4600004)</td></tr>
<tr class="memdesc:ga6cd13d43fe8799f8d51a61c8126ef2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">PI DMA: cartridge address register. <br /></td></tr>
<tr class="separator:ga6cd13d43fe8799f8d51a61c8126ef2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b7271ee52d161475477be5f0642ce47"><td class="memItemLeft" align="right" valign="top"><a id="ga9b7271ee52d161475477be5f0642ce47" name="ga9b7271ee52d161475477be5f0642ce47"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PI_RD_LEN</b>&#160;&#160;&#160;((volatile uint32_t*)0xA4600008)</td></tr>
<tr class="memdesc:ga9b7271ee52d161475477be5f0642ce47"><td class="mdescLeft">&#160;</td><td class="mdescRight">PI DMA: read length register. <br /></td></tr>
<tr class="separator:ga9b7271ee52d161475477be5f0642ce47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga454492300a2a5a3e2ba79fbd82c04944"><td class="memItemLeft" align="right" valign="top"><a id="ga454492300a2a5a3e2ba79fbd82c04944" name="ga454492300a2a5a3e2ba79fbd82c04944"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PI_WR_LEN</b>&#160;&#160;&#160;((volatile uint32_t*)0xA460000C)</td></tr>
<tr class="memdesc:ga454492300a2a5a3e2ba79fbd82c04944"><td class="mdescLeft">&#160;</td><td class="mdescRight">PI DMA: write length register. <br /></td></tr>
<tr class="separator:ga454492300a2a5a3e2ba79fbd82c04944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e1a75ccdd135238f74249425a242ae5"><td class="memItemLeft" align="right" valign="top"><a id="ga8e1a75ccdd135238f74249425a242ae5" name="ga8e1a75ccdd135238f74249425a242ae5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PI_STATUS</b>&#160;&#160;&#160;((volatile uint32_t*)0xA4600010)</td></tr>
<tr class="memdesc:ga8e1a75ccdd135238f74249425a242ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">PI: status register. <br /></td></tr>
<tr class="separator:ga8e1a75ccdd135238f74249425a242ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2cade71044285df66fb11e4187b8a09d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dma.html#ga2cade71044285df66fb11e4187b8a09d">dma_write_raw_async</a> (const void *ram_address, unsigned long pi_address, unsigned long len)</td></tr>
<tr class="memdesc:ga2cade71044285df66fb11e4187b8a09d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start writing data to a peripheral through PI DMA (low-level)  <a href="group__dma.html#ga2cade71044285df66fb11e4187b8a09d">More...</a><br /></td></tr>
<tr class="separator:ga2cade71044285df66fb11e4187b8a09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2af83b128e112eaaf3f27057e0042058"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dma.html#ga2af83b128e112eaaf3f27057e0042058">dma_write</a> (const void *ram_address, unsigned long pi_address, unsigned long len)</td></tr>
<tr class="memdesc:ga2af83b128e112eaaf3f27057e0042058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to a peripheral.  <a href="group__dma.html#ga2af83b128e112eaaf3f27057e0042058">More...</a><br /></td></tr>
<tr class="separator:ga2af83b128e112eaaf3f27057e0042058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad868ada6b4e5c6eafb40a70f7377b900"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dma.html#gad868ada6b4e5c6eafb40a70f7377b900">dma_read_raw_async</a> (void *ram_address, unsigned long pi_address, unsigned long len)</td></tr>
<tr class="memdesc:gad868ada6b4e5c6eafb40a70f7377b900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start reading data from a peripheral through PI DMA (low-level)  <a href="group__dma.html#gad868ada6b4e5c6eafb40a70f7377b900">More...</a><br /></td></tr>
<tr class="separator:gad868ada6b4e5c6eafb40a70f7377b900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67b2fbe3459597747359794ce2e3ddcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dma.html#ga67b2fbe3459597747359794ce2e3ddcc">dma_read_async</a> (void *ram_address, unsigned long pi_address, unsigned long len)</td></tr>
<tr class="memdesc:ga67b2fbe3459597747359794ce2e3ddcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start reading data from a peripheral through PI DMA.  <a href="group__dma.html#ga67b2fbe3459597747359794ce2e3ddcc">More...</a><br /></td></tr>
<tr class="separator:ga67b2fbe3459597747359794ce2e3ddcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58b544e310a21cd57fe01da65cd27693"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dma.html#ga58b544e310a21cd57fe01da65cd27693">dma_read</a> (void *ram_address, unsigned long pi_address, unsigned long len)</td></tr>
<tr class="memdesc:ga58b544e310a21cd57fe01da65cd27693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a peripheral through PI DMA, waiting for completion.  <a href="group__dma.html#ga58b544e310a21cd57fe01da65cd27693">More...</a><br /></td></tr>
<tr class="separator:ga58b544e310a21cd57fe01da65cd27693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89a297ad5b901919cc3c44f08d16dfb0"><td class="memItemLeft" align="right" valign="top"><a id="ga89a297ad5b901919cc3c44f08d16dfb0" name="ga89a297ad5b901919cc3c44f08d16dfb0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dma_wait</b> (void)</td></tr>
<tr class="memdesc:ga89a297ad5b901919cc3c44f08d16dfb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until an async DMA or I/O transfer is finished. <br /></td></tr>
<tr class="separator:ga89a297ad5b901919cc3c44f08d16dfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3594a5188d4cebfeab4ae572dfdeaf0d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dma.html#ga3594a5188d4cebfeab4ae572dfdeaf0d">io_read</a> (uint32_t pi_address)</td></tr>
<tr class="memdesc:ga3594a5188d4cebfeab4ae572dfdeaf0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a 32 bit integer from a peripheral using the CPU.  <a href="group__dma.html#ga3594a5188d4cebfeab4ae572dfdeaf0d">More...</a><br /></td></tr>
<tr class="separator:ga3594a5188d4cebfeab4ae572dfdeaf0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5eb65e76faecd29c36757cdae3b6e36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dma.html#gac5eb65e76faecd29c36757cdae3b6e36">io_write</a> (uint32_t pi_address, uint32_t data)</td></tr>
<tr class="memdesc:gac5eb65e76faecd29c36757cdae3b6e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a 32 bit integer to a peripheral using the CPU.  <a href="group__dma.html#gac5eb65e76faecd29c36757cdae3b6e36">More...</a><br /></td></tr>
<tr class="separator:gac5eb65e76faecd29c36757cdae3b6e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64122532e1682bc912ad46e241730c75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dma.html#ga64122532e1682bc912ad46e241730c75">io_accessible</a> (uint32_t pi_address)</td></tr>
<tr class="memdesc:ga64122532e1682bc912ad46e241730c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the specified PI address can be accessed doing I/O from CPU.  <a href="group__dma.html#ga64122532e1682bc912ad46e241730c75">More...</a><br /></td></tr>
<tr class="separator:ga64122532e1682bc912ad46e241730c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa600a57f1b87a654aace331c12f3577a"><td class="memItemLeft" align="right" valign="top">volatile int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dma.html#gaa600a57f1b87a654aace331c12f3577a">dma_busy</a> (void)</td></tr>
<tr class="memdesc:gaa600a57f1b87a654aace331c12f3577a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the DMA controller is currently busy.  <a href="group__dma.html#gaa600a57f1b87a654aace331c12f3577a">More...</a><br /></td></tr>
<tr class="separator:gaa600a57f1b87a654aace331c12f3577a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >DMA functionality for transfers between cartridge space and RDRAM. </p>
<p >The DMA controller is responsible for handling block and word accesses from the cartridge domain. Because of the nature of the cartridge interface, code cannot use memcpy or standard pointer accesses on memory mapped to the cartridge. Consequently, the peripheral interface (PI) provides a DMA controller for accessing data.</p>
<p >The DMA controller requires no initialization. Using <a class="el" href="group__dma.html#ga58b544e310a21cd57fe01da65cd27693" title="Read data from a peripheral through PI DMA, waiting for completion.">dma_read</a> and <a class="el" href="group__dma.html#ga2af83b128e112eaaf3f27057e0042058" title="Write to a peripheral.">dma_write</a> will allow reading from the cartridge and writing to the cartridge respectively in block mode. <a class="el" href="group__dma.html#ga3594a5188d4cebfeab4ae572dfdeaf0d" title="Read a 32 bit integer from a peripheral using the CPU.">io_read</a> and <a class="el" href="group__dma.html#gac5eb65e76faecd29c36757cdae3b6e36" title="Write a 32 bit integer to a peripheral using the CPU.">io_write</a> will allow a single 32-bit integer to be read from or written to the cartridge. These are especially useful for manipulating registers on a cartridge such as a gameshark. Code should never make raw 32-bit reads or writes in the cartridge domain as it could collide with an in-progress DMA transfer or run into caching issues. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2cade71044285df66fb11e4187b8a09d" name="ga2cade71044285df66fb11e4187b8a09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cade71044285df66fb11e4187b8a09d">&#9670;&nbsp;</a></span>dma_write_raw_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dma_write_raw_async </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ram_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>pi_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start writing data to a peripheral through PI DMA (low-level) </p>
<p >This function should be used when writing to a cartridge peripheral (typically ROM). This function just begins executing a raw DMA transfer, which is well-defined only for RAM addresses which are multiple of 8, ROM addresses which are multiple of 2, and lengths which are multiple of 2.</p>
<p >Use <a class="el" href="group__dma.html#ga89a297ad5b901919cc3c44f08d16dfb0" title="Wait until an async DMA or I/O transfer is finished.">dma_wait</a> to wait for the end of the transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ram_address</td><td>Pointer to a buffer to read data from (must be 8-byte aligned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pi_address</td><td>Memory address of the peripheral to write to (must be 2-byte aligned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length in bytes to write into pi_address (must be multiple of 2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2af83b128e112eaaf3f27057e0042058" name="ga2af83b128e112eaaf3f27057e0042058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2af83b128e112eaaf3f27057e0042058">&#9670;&nbsp;</a></span>dma_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dma_write </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ram_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>pi_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to a peripheral. </p>
<p >This function should be used when writing to the cartridge.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ram_address</td><td>Pointer to a buffer to read data from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pi_address</td><td>Cartridge address to write to (must be in range (0x10000000-0x1FFFFFFF). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length in bytes to write to peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function has always had an historical mistake: the pi_address is mangled to be forced into the ROM area (0x10000000-0x1FFFFFFF). This is wrong as the PI bus has full 32-bit address, and the same function could have been used to access the whole range. If you need to read outside the ROM area, use <a class="el" href="group__dma.html#ga2cade71044285df66fb11e4187b8a09d" title="Start writing data to a peripheral through PI DMA (low-level)">dma_write_raw_async</a> instead. </dd></dl>

</div>
</div>
<a id="gad868ada6b4e5c6eafb40a70f7377b900" name="gad868ada6b4e5c6eafb40a70f7377b900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad868ada6b4e5c6eafb40a70f7377b900">&#9670;&nbsp;</a></span>dma_read_raw_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dma_read_raw_async </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ram_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>pi_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start reading data from a peripheral through PI DMA (low-level) </p>
<p >This function should be used when reading from a cartridge peripheral (typically ROM). This function just begins executing a raw DMA transfer, which is well-defined only for RAM addresses which are multiple of 8, ROM addresses which are multiple of 2, and lengths which are multiple of 2.</p>
<p >Use <a class="el" href="group__dma.html#ga89a297ad5b901919cc3c44f08d16dfb0" title="Wait until an async DMA or I/O transfer is finished.">dma_wait</a> to wait for the end of the transfer.</p>
<p >See <a class="el" href="group__dma.html#ga67b2fbe3459597747359794ce2e3ddcc" title="Start reading data from a peripheral through PI DMA.">dma_read_async</a> for a higher level primitive which can perform almost arbitrary transfers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ram_address</td><td>Pointer to a buffer to place read data (must be 8-byte aligned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pi_address</td><td>Memory address of the peripheral to read from (must be 2-byte aligned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length in bytes to read into ram_address (must be multiple of 2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga67b2fbe3459597747359794ce2e3ddcc" name="ga67b2fbe3459597747359794ce2e3ddcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67b2fbe3459597747359794ce2e3ddcc">&#9670;&nbsp;</a></span>dma_read_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dma_read_async </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ram_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>pi_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start reading data from a peripheral through PI DMA. </p>
<p >This function must be used when reading a chunk of data from a cartridge peripheral (typically, ROM). It is a wrapper over <a class="el" href="group__dma.html#gad868ada6b4e5c6eafb40a70f7377b900" title="Start reading data from a peripheral through PI DMA (low-level)">dma_read_raw_async</a> that allows arbitrary aligned addresses and any length (including odd sizes). For fully-aligned addresses it quickly falls back to <a class="el" href="group__dma.html#gad868ada6b4e5c6eafb40a70f7377b900" title="Start reading data from a peripheral through PI DMA (low-level)">dma_read_raw_async</a>, so it can be used generically as "default" PI DMA transfer function.</p>
<p >The only constraint on alignment is that the RAM and PI addresses must have the same 1-bit misalignment, that is they must either be even addresses or odd addresses. Notice that this function will assert if this constraint is not respected.</p>
<p >Use <a class="el" href="group__dma.html#ga89a297ad5b901919cc3c44f08d16dfb0" title="Wait until an async DMA or I/O transfer is finished.">dma_wait</a> to wait for the end of the transfer.</p>
<p >For non performance sensitive tasks such as reading and parsing data from ROM at loading time, a better option is to use DragonFS, where <a class="el" href="dragonfs_8h.html#a7c0acaa1af10520da638633ab73b9287" title="Read data from a file.">dfs_read</a> falls back to a CPU memory copy to realign the data when required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ram_address</td><td>Pointer to a buffer in RDRAM to place read data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pi_address</td><td>Memory address of the peripheral to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length in bytes to read into ram_pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga58b544e310a21cd57fe01da65cd27693" name="ga58b544e310a21cd57fe01da65cd27693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58b544e310a21cd57fe01da65cd27693">&#9670;&nbsp;</a></span>dma_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dma_read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ram_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>pi_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from a peripheral through PI DMA, waiting for completion. </p>
<p >This function performs a blocking read. See <a class="el" href="group__dma.html#ga67b2fbe3459597747359794ce2e3ddcc" title="Start reading data from a peripheral through PI DMA.">dma_read_async</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ram_address</td><td>Pointer to a buffer in RDRAM to place read data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pi_address</td><td>ROM address to read from (must be in range (0x10000000-0x1FFFFFFF). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length in bytes to read into ram_address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function has always had an historical mistake: the pi_address is mangled to be forced into the ROM area (0x10000000-0x1FFFFFFF). This is wrong as the PI bus has full 32-bit address, and the same function could have been used to access the whole range. If you need to read outside the ROM area, use <a class="el" href="group__dma.html#ga67b2fbe3459597747359794ce2e3ddcc" title="Start reading data from a peripheral through PI DMA.">dma_read_async</a> instead. </dd></dl>

</div>
</div>
<a id="ga3594a5188d4cebfeab4ae572dfdeaf0d" name="ga3594a5188d4cebfeab4ae572dfdeaf0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3594a5188d4cebfeab4ae572dfdeaf0d">&#9670;&nbsp;</a></span>io_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t io_read </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a 32 bit integer from a peripheral using the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pi_address</td><td>Memory address of the peripheral to read from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32 bit value read from the peripheral</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function only works if the specified PI address falls within a range which is memory mapped on the CPU. See <a class="el" href="group__dma.html#ga64122532e1682bc912ad46e241730c75" title="Check whether the specified PI address can be accessed doing I/O from CPU.">io_accessible</a> for more information.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dma.html#ga64122532e1682bc912ad46e241730c75" title="Check whether the specified PI address can be accessed doing I/O from CPU.">io_accessible</a> </dd></dl>

</div>
</div>
<a id="gac5eb65e76faecd29c36757cdae3b6e36" name="gac5eb65e76faecd29c36757cdae3b6e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5eb65e76faecd29c36757cdae3b6e36">&#9670;&nbsp;</a></span>io_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void io_write </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a 32 bit integer to a peripheral using the CPU. </p>
<p >Notice that writes are performed asynchronously, so the data might have not been fully written to the peripheral yet when the function returns. Use <a class="el" href="group__dma.html#ga89a297ad5b901919cc3c44f08d16dfb0" title="Wait until an async DMA or I/O transfer is finished.">dma_wait</a> if you need to wait for the transfer to be finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pi_address</td><td>Memory address of the peripheral to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>32 bit value to write to peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function only works if the specified PI address falls within a range which is memory mapped on the CPU. See <a class="el" href="group__dma.html#ga64122532e1682bc912ad46e241730c75" title="Check whether the specified PI address can be accessed doing I/O from CPU.">io_accessible</a> for more information.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dma.html#ga64122532e1682bc912ad46e241730c75" title="Check whether the specified PI address can be accessed doing I/O from CPU.">io_accessible</a> </dd></dl>

</div>
</div>
<a id="ga64122532e1682bc912ad46e241730c75" name="ga64122532e1682bc912ad46e241730c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64122532e1682bc912ad46e241730c75">&#9670;&nbsp;</a></span>io_accessible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool io_accessible </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the specified PI address can be accessed doing I/O from CPU. </p>
<p >The PI bus covers the full 32-bit address range. The full range is only accessible via DMA, though. A part of the range is also memory mapped to the CPU and can be accessed via <a class="el" href="group__dma.html#ga3594a5188d4cebfeab4ae572dfdeaf0d" title="Read a 32 bit integer from a peripheral using the CPU.">io_read</a> and <a class="el" href="group__dma.html#gac5eb65e76faecd29c36757cdae3b6e36" title="Write a 32 bit integer to a peripheral using the CPU.">io_write</a>.</p>
<p >The ranges of PI address that can be accessed via CPU are:</p>
<ul>
<li>0x0500_0000 - 0x0FFF_FFFF: used by N64DD and SRAM on cartridge</li>
<li>0x1000_0000 - 0x1FBF_FFFF: cartridge ROM</li>
<li>0x1FD0_0000 - 0x1FFF_FFFF: no known PI peripherals use this</li>
</ul>
<p >The rest of the 32-bit address range is only accessible via DMA.</p>
<p >Notice also that the range 0x2000_0000 - 0x7FFF_FFFF is theoretically accessible by the CPU but only via 64-bit addressing, so it requires assembly instructions (as the libdragon toolchain uses 32-bit pointers). No known PI peripherals use this range anyway.</p>
<p >This function checks whether the specified address falls into the range accessible via CPU or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pi_address</td><td>PI address to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the address is memory mapped, false if it is not </dd></dl>

</div>
</div>
<a id="gaa600a57f1b87a654aace331c12f3577a" name="gaa600a57f1b87a654aace331c12f3577a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa600a57f1b87a654aace331c12f3577a">&#9670;&nbsp;</a></span>dma_busy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile int dma_busy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether the DMA controller is currently busy. </p>
<dl class="section return"><dt>Returns</dt><dd>nonzero if the DMA controller is busy or 0 otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
