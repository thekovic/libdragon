<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libdragon: Interrupt Controller</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libdragon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Interrupt Controller<div class="ingroups"><a class="el" href="group__libdragon.html">libdragon</a> &raquo; <a class="el" href="group__lowlevel.html">Low Level Hardware Interfaces</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>N64 interrupt registering and servicing routines.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:interrupt_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interrupt_8c.html">interrupt.c</a></td></tr>
<tr class="memdesc:interrupt_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt Controller. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:interrupt_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interrupt_8h.html">interrupt.h</a></td></tr>
<tr class="memdesc:interrupt_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt Controller. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__callback__link.html">_callback_link</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure of an interrupt callback.  <a href="struct__callback__link.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga883150d32c343267c7c046c0f55cc44b"><td class="memItemLeft" align="right" valign="top"><a id="ga883150d32c343267c7c046c0f55cc44b" name="ga883150d32c343267c7c046c0f55cc44b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PI_CLEAR_INTERRUPT</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:ga883150d32c343267c7c046c0f55cc44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit to set to clear the PI interrupt. <br /></td></tr>
<tr class="separator:ga883150d32c343267c7c046c0f55cc44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cd374a8b3a1a6860b954fe5873de4f9"><td class="memItemLeft" align="right" valign="top"><a id="ga8cd374a8b3a1a6860b954fe5873de4f9" name="ga8cd374a8b3a1a6860b954fe5873de4f9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SI_CLEAR_INTERRUPT</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga8cd374a8b3a1a6860b954fe5873de4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit to set to clear the SI interrupt. <br /></td></tr>
<tr class="separator:ga8cd374a8b3a1a6860b954fe5873de4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae77f2cb1a7d705ceac06d7e108a4372c"><td class="memItemLeft" align="right" valign="top"><a id="gae77f2cb1a7d705ceac06d7e108a4372c" name="gae77f2cb1a7d705ceac06d7e108a4372c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SP_CLEAR_INTERRUPT</b>&#160;&#160;&#160;0x08</td></tr>
<tr class="memdesc:gae77f2cb1a7d705ceac06d7e108a4372c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit to set to clear the SP interrupt. <br /></td></tr>
<tr class="separator:gae77f2cb1a7d705ceac06d7e108a4372c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6203c83bc7406116b82e34e6a9c40d7"><td class="memItemLeft" align="right" valign="top"><a id="gaf6203c83bc7406116b82e34e6a9c40d7" name="gaf6203c83bc7406116b82e34e6a9c40d7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DP_CLEAR_INTERRUPT</b>&#160;&#160;&#160;0x0800</td></tr>
<tr class="memdesc:gaf6203c83bc7406116b82e34e6a9c40d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit to set to clear the DP interrupt. <br /></td></tr>
<tr class="separator:gaf6203c83bc7406116b82e34e6a9c40d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga873569a84cb252b7fba9007669c89517"><td class="memItemLeft" align="right" valign="top"><a id="ga873569a84cb252b7fba9007669c89517" name="ga873569a84cb252b7fba9007669c89517"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_CLEAR_INTERRUPT</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga873569a84cb252b7fba9007669c89517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit to set to clear the AI interrupt. <br /></td></tr>
<tr class="separator:ga873569a84cb252b7fba9007669c89517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf76584f6b55e9cac50bf3f3a706f3428"><td class="memItemLeft" align="right" valign="top"><a id="gaf76584f6b55e9cac50bf3f3a706f3428" name="gaf76584f6b55e9cac50bf3f3a706f3428"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_RESET_HANDLERS</b>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:gaf76584f6b55e9cac50bf3f3a706f3428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of reset handlers that can be registered. <br /></td></tr>
<tr class="separator:gaf76584f6b55e9cac50bf3f3a706f3428"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga366982e291c08c36c7352ea07a6e096c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga366982e291c08c36c7352ea07a6e096c">interrupt_state_t</a> { <a class="el" href="group__interrupt.html#gga366982e291c08c36c7352ea07a6e096ca8391f9b3514597a92d66f4ec813bbe22">INTERRUPTS_UNINITIALIZED</a>
, <a class="el" href="group__interrupt.html#gga366982e291c08c36c7352ea07a6e096ca199b2924f37a683a3dfcae49aac28b67">INTERRUPTS_DISABLED</a>
, <a class="el" href="group__interrupt.html#gga366982e291c08c36c7352ea07a6e096ca63f9f656dbca41f104246bcb920cc110">INTERRUPTS_ENABLED</a>
 }</td></tr>
<tr class="memdesc:ga366982e291c08c36c7352ea07a6e096c"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of interrupts on the system.  <a href="group__interrupt.html#ga366982e291c08c36c7352ea07a6e096c">More...</a><br /></td></tr>
<tr class="separator:ga366982e291c08c36c7352ea07a6e096c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga35d016d7a4cff493528719125cf54e8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga35d016d7a4cff493528719125cf54e8d">__MI_handler</a> (void)</td></tr>
<tr class="memdesc:ga35d016d7a4cff493528719125cf54e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle an MI interrupt.  <a href="group__interrupt.html#ga35d016d7a4cff493528719125cf54e8d">More...</a><br /></td></tr>
<tr class="separator:ga35d016d7a4cff493528719125cf54e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0eece989af0383b0994b3a22c6d1960"><td class="memItemLeft" align="right" valign="top"><a id="gac0eece989af0383b0994b3a22c6d1960" name="gac0eece989af0383b0994b3a22c6d1960"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__TI_handler</b> (void)</td></tr>
<tr class="memdesc:gac0eece989af0383b0994b3a22c6d1960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle a timer interrupt. <br /></td></tr>
<tr class="separator:gac0eece989af0383b0994b3a22c6d1960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cb68df23ed3587601ffac775b9a953c"><td class="memItemLeft" align="right" valign="top"><a id="ga9cb68df23ed3587601ffac775b9a953c" name="ga9cb68df23ed3587601ffac775b9a953c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__CART_handler</b> (void)</td></tr>
<tr class="memdesc:ga9cb68df23ed3587601ffac775b9a953c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle a CART interrupt. <br /></td></tr>
<tr class="separator:ga9cb68df23ed3587601ffac775b9a953c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d2950dd0d587a88e65537694b721544"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga2d2950dd0d587a88e65537694b721544">__RESET_handler</a> (void)</td></tr>
<tr class="memdesc:ga2d2950dd0d587a88e65537694b721544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle a RESET (pre-NMI) interrupt.  <a href="group__interrupt.html#ga2d2950dd0d587a88e65537694b721544">More...</a><br /></td></tr>
<tr class="separator:ga2d2950dd0d587a88e65537694b721544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2351876167328732c7ff03de3c4081db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga2351876167328732c7ff03de3c4081db">register_AI_handler</a> (void(*callback)())</td></tr>
<tr class="memdesc:ga2351876167328732c7ff03de3c4081db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an AI callback.  <a href="group__interrupt.html#ga2351876167328732c7ff03de3c4081db">More...</a><br /></td></tr>
<tr class="separator:ga2351876167328732c7ff03de3c4081db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05ed635fdfe7b72490e6bca3d82a9844"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga05ed635fdfe7b72490e6bca3d82a9844">unregister_AI_handler</a> (void(*callback)())</td></tr>
<tr class="memdesc:ga05ed635fdfe7b72490e6bca3d82a9844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister an AI callback.  <a href="group__interrupt.html#ga05ed635fdfe7b72490e6bca3d82a9844">More...</a><br /></td></tr>
<tr class="separator:ga05ed635fdfe7b72490e6bca3d82a9844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3d1ab2fc7617f717482d0a8896372ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#gab3d1ab2fc7617f717482d0a8896372ab">register_VI_handler</a> (void(*callback)())</td></tr>
<tr class="memdesc:gab3d1ab2fc7617f717482d0a8896372ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a VI callback.  <a href="group__interrupt.html#gab3d1ab2fc7617f717482d0a8896372ab">More...</a><br /></td></tr>
<tr class="separator:gab3d1ab2fc7617f717482d0a8896372ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga432eef7630772dfe5a26b2440122c379"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga432eef7630772dfe5a26b2440122c379">unregister_VI_handler</a> (void(*callback)())</td></tr>
<tr class="memdesc:ga432eef7630772dfe5a26b2440122c379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a VI callback.  <a href="group__interrupt.html#ga432eef7630772dfe5a26b2440122c379">More...</a><br /></td></tr>
<tr class="separator:ga432eef7630772dfe5a26b2440122c379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd3c4fb02d0c955af17793c453bbfc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga3dd3c4fb02d0c955af17793c453bbfc3">register_PI_handler</a> (void(*callback)())</td></tr>
<tr class="memdesc:ga3dd3c4fb02d0c955af17793c453bbfc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a PI callback.  <a href="group__interrupt.html#ga3dd3c4fb02d0c955af17793c453bbfc3">More...</a><br /></td></tr>
<tr class="separator:ga3dd3c4fb02d0c955af17793c453bbfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d6944493768b6d604359d0cdbe5bed4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga7d6944493768b6d604359d0cdbe5bed4">unregister_PI_handler</a> (void(*callback)())</td></tr>
<tr class="memdesc:ga7d6944493768b6d604359d0cdbe5bed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unegister a PI callback.  <a href="group__interrupt.html#ga7d6944493768b6d604359d0cdbe5bed4">More...</a><br /></td></tr>
<tr class="separator:ga7d6944493768b6d604359d0cdbe5bed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf41859f72b17670b89d7a117721f599f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#gaf41859f72b17670b89d7a117721f599f">register_DP_handler</a> (void(*callback)())</td></tr>
<tr class="memdesc:gaf41859f72b17670b89d7a117721f599f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a DP callback.  <a href="group__interrupt.html#gaf41859f72b17670b89d7a117721f599f">More...</a><br /></td></tr>
<tr class="separator:gaf41859f72b17670b89d7a117721f599f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga576a9619c9c5e42863664ed1dcbb7d11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga576a9619c9c5e42863664ed1dcbb7d11">unregister_DP_handler</a> (void(*callback)())</td></tr>
<tr class="memdesc:ga576a9619c9c5e42863664ed1dcbb7d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a DP callback.  <a href="group__interrupt.html#ga576a9619c9c5e42863664ed1dcbb7d11">More...</a><br /></td></tr>
<tr class="separator:ga576a9619c9c5e42863664ed1dcbb7d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ed676471062e227ad17ac859b22163"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#gae2ed676471062e227ad17ac859b22163">register_SI_handler</a> (void(*callback)())</td></tr>
<tr class="memdesc:gae2ed676471062e227ad17ac859b22163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a SI callback.  <a href="group__interrupt.html#gae2ed676471062e227ad17ac859b22163">More...</a><br /></td></tr>
<tr class="separator:gae2ed676471062e227ad17ac859b22163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga082b7cf2be05e8d07404572f0d5a96b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga082b7cf2be05e8d07404572f0d5a96b0">unregister_SI_handler</a> (void(*callback)())</td></tr>
<tr class="memdesc:ga082b7cf2be05e8d07404572f0d5a96b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unegister a SI callback.  <a href="group__interrupt.html#ga082b7cf2be05e8d07404572f0d5a96b0">More...</a><br /></td></tr>
<tr class="separator:ga082b7cf2be05e8d07404572f0d5a96b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3079522044b52381718fc0f7348879e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#gaf3079522044b52381718fc0f7348879e">register_SP_handler</a> (void(*callback)())</td></tr>
<tr class="memdesc:gaf3079522044b52381718fc0f7348879e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a SP callback.  <a href="group__interrupt.html#gaf3079522044b52381718fc0f7348879e">More...</a><br /></td></tr>
<tr class="separator:gaf3079522044b52381718fc0f7348879e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3983fa9ec9de4022655d4153b39bead"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#gad3983fa9ec9de4022655d4153b39bead">unregister_SP_handler</a> (void(*callback)())</td></tr>
<tr class="memdesc:gad3983fa9ec9de4022655d4153b39bead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unegister a SP callback.  <a href="group__interrupt.html#gad3983fa9ec9de4022655d4153b39bead">More...</a><br /></td></tr>
<tr class="separator:gad3983fa9ec9de4022655d4153b39bead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d5470e13ad8f649ba02b833630d6abf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga9d5470e13ad8f649ba02b833630d6abf">register_TI_handler</a> (void(*callback)())</td></tr>
<tr class="memdesc:ga9d5470e13ad8f649ba02b833630d6abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a timer callback.  <a href="group__interrupt.html#ga9d5470e13ad8f649ba02b833630d6abf">More...</a><br /></td></tr>
<tr class="separator:ga9d5470e13ad8f649ba02b833630d6abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cc1089f8fe22245df63d22f314a95d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga1cc1089f8fe22245df63d22f314a95d6">unregister_TI_handler</a> (void(*callback)())</td></tr>
<tr class="memdesc:ga1cc1089f8fe22245df63d22f314a95d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a timer callback.  <a href="group__interrupt.html#ga1cc1089f8fe22245df63d22f314a95d6">More...</a><br /></td></tr>
<tr class="separator:ga1cc1089f8fe22245df63d22f314a95d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bb059c6f6872f28fec2a819541279f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga0bb059c6f6872f28fec2a819541279f4">register_CART_handler</a> (void(*callback)())</td></tr>
<tr class="memdesc:ga0bb059c6f6872f28fec2a819541279f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a CART interrupt callback.  <a href="group__interrupt.html#ga0bb059c6f6872f28fec2a819541279f4">More...</a><br /></td></tr>
<tr class="separator:ga0bb059c6f6872f28fec2a819541279f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f0506a6313156207431898c0fb400ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga7f0506a6313156207431898c0fb400ec">unregister_CART_handler</a> (void(*callback)())</td></tr>
<tr class="memdesc:ga7f0506a6313156207431898c0fb400ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a CART interrupt callback.  <a href="group__interrupt.html#ga7f0506a6313156207431898c0fb400ec">More...</a><br /></td></tr>
<tr class="separator:ga7f0506a6313156207431898c0fb400ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabbbbb20f064ac035492af4a8763ef44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#gaabbbbb20f064ac035492af4a8763ef44">register_RESET_handler</a> (void(*callback)())</td></tr>
<tr class="memdesc:gaabbbbb20f064ac035492af4a8763ef44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a handler that will be called when the user presses the RESET button.  <a href="group__interrupt.html#gaabbbbb20f064ac035492af4a8763ef44">More...</a><br /></td></tr>
<tr class="separator:gaabbbbb20f064ac035492af4a8763ef44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b29ebe8db68cdbee591e8d15693cb5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga2b29ebe8db68cdbee591e8d15693cb5f">unregister_RESET_handler</a> (void(*callback)())</td></tr>
<tr class="memdesc:ga2b29ebe8db68cdbee591e8d15693cb5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a RESET interrupt callback.  <a href="group__interrupt.html#ga2b29ebe8db68cdbee591e8d15693cb5f">More...</a><br /></td></tr>
<tr class="separator:ga2b29ebe8db68cdbee591e8d15693cb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87288d9e8d2c178572957295ff64ec40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga87288d9e8d2c178572957295ff64ec40">set_AI_interrupt</a> (int active)</td></tr>
<tr class="memdesc:ga87288d9e8d2c178572957295ff64ec40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the AI interrupt.  <a href="group__interrupt.html#ga87288d9e8d2c178572957295ff64ec40">More...</a><br /></td></tr>
<tr class="separator:ga87288d9e8d2c178572957295ff64ec40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf53fd03f791d5a936e7db39f5c7959c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#gaf53fd03f791d5a936e7db39f5c7959c1">set_VI_interrupt</a> (int active, unsigned long line)</td></tr>
<tr class="memdesc:gaf53fd03f791d5a936e7db39f5c7959c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the VI interrupt.  <a href="group__interrupt.html#gaf53fd03f791d5a936e7db39f5c7959c1">More...</a><br /></td></tr>
<tr class="separator:gaf53fd03f791d5a936e7db39f5c7959c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a5ec9c8b19060b6d4c7126cc670cf37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga6a5ec9c8b19060b6d4c7126cc670cf37">set_PI_interrupt</a> (int active)</td></tr>
<tr class="memdesc:ga6a5ec9c8b19060b6d4c7126cc670cf37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the PI interrupt.  <a href="group__interrupt.html#ga6a5ec9c8b19060b6d4c7126cc670cf37">More...</a><br /></td></tr>
<tr class="separator:ga6a5ec9c8b19060b6d4c7126cc670cf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0b3939ccf8c8eff2289c08a75cbc624"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#gad0b3939ccf8c8eff2289c08a75cbc624">set_DP_interrupt</a> (int active)</td></tr>
<tr class="memdesc:gad0b3939ccf8c8eff2289c08a75cbc624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the DP interrupt.  <a href="group__interrupt.html#gad0b3939ccf8c8eff2289c08a75cbc624">More...</a><br /></td></tr>
<tr class="separator:gad0b3939ccf8c8eff2289c08a75cbc624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2852664ce3950d66868cf39d8d633d62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga2852664ce3950d66868cf39d8d633d62">set_SI_interrupt</a> (int active)</td></tr>
<tr class="memdesc:ga2852664ce3950d66868cf39d8d633d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the SI interrupt.  <a href="group__interrupt.html#ga2852664ce3950d66868cf39d8d633d62">More...</a><br /></td></tr>
<tr class="separator:ga2852664ce3950d66868cf39d8d633d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24c9ae3233fc77e0f6a1a22843c88298"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga24c9ae3233fc77e0f6a1a22843c88298">set_SP_interrupt</a> (int active)</td></tr>
<tr class="memdesc:ga24c9ae3233fc77e0f6a1a22843c88298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the SP interrupt.  <a href="group__interrupt.html#ga24c9ae3233fc77e0f6a1a22843c88298">More...</a><br /></td></tr>
<tr class="separator:ga24c9ae3233fc77e0f6a1a22843c88298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67483ed4435081b227aa799465cb7436"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga67483ed4435081b227aa799465cb7436">set_TI_interrupt</a> (int active)</td></tr>
<tr class="memdesc:ga67483ed4435081b227aa799465cb7436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the timer interrupt.  <a href="group__interrupt.html#ga67483ed4435081b227aa799465cb7436">More...</a><br /></td></tr>
<tr class="separator:ga67483ed4435081b227aa799465cb7436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7ddaefc83763af0e97886beb7600d8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#gac7ddaefc83763af0e97886beb7600d8b">set_CART_interrupt</a> (int active)</td></tr>
<tr class="memdesc:gac7ddaefc83763af0e97886beb7600d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the CART interrupt.  <a href="group__interrupt.html#gac7ddaefc83763af0e97886beb7600d8b">More...</a><br /></td></tr>
<tr class="separator:gac7ddaefc83763af0e97886beb7600d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcf484e0e3594849dfcaea7e5c69ffe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#gadcf484e0e3594849dfcaea7e5c69ffe7">set_RESET_interrupt</a> (int active)</td></tr>
<tr class="memdesc:gadcf484e0e3594849dfcaea7e5c69ffe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the RESET interrupt.  <a href="group__interrupt.html#gadcf484e0e3594849dfcaea7e5c69ffe7">More...</a><br /></td></tr>
<tr class="separator:gadcf484e0e3594849dfcaea7e5c69ffe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72e02641a29de5f343f8507140b46b8e"><td class="memItemLeft" align="right" valign="top"><a id="ga72e02641a29de5f343f8507140b46b8e" name="ga72e02641a29de5f343f8507140b46b8e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__init_interrupts</b> ()</td></tr>
<tr class="memdesc:ga72e02641a29de5f343f8507140b46b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the interrupt controller. <br /></td></tr>
<tr class="separator:ga72e02641a29de5f343f8507140b46b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52651bf1923b2c97e8b4da0ac6b99fdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga52651bf1923b2c97e8b4da0ac6b99fdb">disable_interrupts</a> ()</td></tr>
<tr class="memdesc:ga52651bf1923b2c97e8b4da0ac6b99fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable interrupts systemwide.  <a href="group__interrupt.html#ga52651bf1923b2c97e8b4da0ac6b99fdb">More...</a><br /></td></tr>
<tr class="separator:ga52651bf1923b2c97e8b4da0ac6b99fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga154b837080a092ecbab0735a0254c4b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga154b837080a092ecbab0735a0254c4b4">enable_interrupts</a> ()</td></tr>
<tr class="memdesc:ga154b837080a092ecbab0735a0254c4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable interrupts systemwide.  <a href="group__interrupt.html#ga154b837080a092ecbab0735a0254c4b4">More...</a><br /></td></tr>
<tr class="separator:ga154b837080a092ecbab0735a0254c4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf84369f06d965c3fdba355cad7e71e89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__interrupt.html#ga366982e291c08c36c7352ea07a6e096c">interrupt_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#gaf84369f06d965c3fdba355cad7e71e89">get_interrupts_state</a> ()</td></tr>
<tr class="memdesc:gaf84369f06d965c3fdba355cad7e71e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current state of interrupts.  <a href="group__interrupt.html#gaf84369f06d965c3fdba355cad7e71e89">More...</a><br /></td></tr>
<tr class="separator:gaf84369f06d965c3fdba355cad7e71e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga288a573e9c25f474c0e71cfcde6f388a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga288a573e9c25f474c0e71cfcde6f388a">exception_reset_time</a> (void)</td></tr>
<tr class="memdesc:ga288a573e9c25f474c0e71cfcde6f388a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the RESET button was pressed and how long we are into the reset process.  <a href="group__interrupt.html#ga288a573e9c25f474c0e71cfcde6f388a">More...</a><br /></td></tr>
<tr class="separator:ga288a573e9c25f474c0e71cfcde6f388a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gafeab012ae992c1b832d27fa54ed75b03"><td class="memItemLeft" align="right" valign="top"><a id="gafeab012ae992c1b832d27fa54ed75b03" name="gafeab012ae992c1b832d27fa54ed75b03"></a>
struct callback_link *&#160;</td><td class="memItemRight" valign="bottom"><b>AI_callback</b> = 0</td></tr>
<tr class="memdesc:gafeab012ae992c1b832d27fa54ed75b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linked list of AI callbacks. <br /></td></tr>
<tr class="separator:gafeab012ae992c1b832d27fa54ed75b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae53298ee0d7e09b763c88bce13f41d58"><td class="memItemLeft" align="right" valign="top"><a id="gae53298ee0d7e09b763c88bce13f41d58" name="gae53298ee0d7e09b763c88bce13f41d58"></a>
struct callback_link *&#160;</td><td class="memItemRight" valign="bottom"><b>VI_callback</b> = 0</td></tr>
<tr class="memdesc:gae53298ee0d7e09b763c88bce13f41d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linked list of VI callbacks. <br /></td></tr>
<tr class="separator:gae53298ee0d7e09b763c88bce13f41d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga854264d1f490b40f57596a9efd6d7fe6"><td class="memItemLeft" align="right" valign="top"><a id="ga854264d1f490b40f57596a9efd6d7fe6" name="ga854264d1f490b40f57596a9efd6d7fe6"></a>
struct callback_link *&#160;</td><td class="memItemRight" valign="bottom"><b>PI_callback</b> = 0</td></tr>
<tr class="memdesc:ga854264d1f490b40f57596a9efd6d7fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linked list of PI callbacks. <br /></td></tr>
<tr class="separator:ga854264d1f490b40f57596a9efd6d7fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d91906f92df789296192c5b4b0ba072"><td class="memItemLeft" align="right" valign="top"><a id="ga5d91906f92df789296192c5b4b0ba072" name="ga5d91906f92df789296192c5b4b0ba072"></a>
struct callback_link *&#160;</td><td class="memItemRight" valign="bottom"><b>DP_callback</b> = 0</td></tr>
<tr class="memdesc:ga5d91906f92df789296192c5b4b0ba072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linked list of DP callbacks. <br /></td></tr>
<tr class="separator:ga5d91906f92df789296192c5b4b0ba072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cb8e491a3e1ca60b7a10731e2c33711"><td class="memItemLeft" align="right" valign="top"><a id="ga5cb8e491a3e1ca60b7a10731e2c33711" name="ga5cb8e491a3e1ca60b7a10731e2c33711"></a>
struct callback_link *&#160;</td><td class="memItemRight" valign="bottom"><b>SI_callback</b> = 0</td></tr>
<tr class="memdesc:ga5cb8e491a3e1ca60b7a10731e2c33711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linked list of SI callbacks. <br /></td></tr>
<tr class="separator:ga5cb8e491a3e1ca60b7a10731e2c33711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dcb2022913d189e49c6a027ba4c1089"><td class="memItemLeft" align="right" valign="top"><a id="ga6dcb2022913d189e49c6a027ba4c1089" name="ga6dcb2022913d189e49c6a027ba4c1089"></a>
struct callback_link *&#160;</td><td class="memItemRight" valign="bottom"><b>SP_callback</b> = 0</td></tr>
<tr class="memdesc:ga6dcb2022913d189e49c6a027ba4c1089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linked list of SP callbacks. <br /></td></tr>
<tr class="separator:ga6dcb2022913d189e49c6a027ba4c1089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f26639aff9cc91b67b52f6a7e373e63"><td class="memItemLeft" align="right" valign="top"><a id="ga6f26639aff9cc91b67b52f6a7e373e63" name="ga6f26639aff9cc91b67b52f6a7e373e63"></a>
struct callback_link *&#160;</td><td class="memItemRight" valign="bottom"><b>TI_callback</b> = 0</td></tr>
<tr class="memdesc:ga6f26639aff9cc91b67b52f6a7e373e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linked list of TI callbacks. <br /></td></tr>
<tr class="separator:ga6f26639aff9cc91b67b52f6a7e373e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga573de59e71ea77bd0697642b8c4e9729"><td class="memItemLeft" align="right" valign="top"><a id="ga573de59e71ea77bd0697642b8c4e9729" name="ga573de59e71ea77bd0697642b8c4e9729"></a>
struct callback_link *&#160;</td><td class="memItemRight" valign="bottom"><b>CART_callback</b> = 0</td></tr>
<tr class="memdesc:ga573de59e71ea77bd0697642b8c4e9729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linked list of CART callbacks. <br /></td></tr>
<tr class="separator:ga573de59e71ea77bd0697642b8c4e9729"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >N64 interrupt registering and servicing routines. </p>
<p >The N64 interrupt controller provides a software interface to register for interrupts from the various systems in the N64. Most interrupts on the N64 coordinate through the MIPS interface (MI) to allow interrupts to be handled at one spot. A notable exception is the timer interrupt which is generated by the MIPS r4300 itself and not the N64 hardware.</p>
<p >The interrupt controller is automatically initialized before main is called. By default, all interrupts are enabled and any registered callback can be called when an interrupt occurs. Each of the N64-generated interrupts is maskable using the various set accessors.</p>
<p >Interrupts can be enabled or disabled as a whole on the N64 using <a class="el" href="group__interrupt.html#ga154b837080a092ecbab0735a0254c4b4" title="Enable interrupts systemwide.">enable_interrupts</a> and <a class="el" href="group__interrupt.html#ga52651bf1923b2c97e8b4da0ac6b99fdb" title="Disable interrupts systemwide.">disable_interrupts</a>. It is assumed that once the interrupt system is activated, these will always be called in pairs. Calling <a class="el" href="group__interrupt.html#ga154b837080a092ecbab0735a0254c4b4" title="Enable interrupts systemwide.">enable_interrupts</a> without first calling <a class="el" href="group__interrupt.html#ga52651bf1923b2c97e8b4da0ac6b99fdb" title="Disable interrupts systemwide.">disable_interrupts</a> is considered a violation of this assumption and should be avoided. Calling <a class="el" href="group__interrupt.html#ga52651bf1923b2c97e8b4da0ac6b99fdb" title="Disable interrupts systemwide.">disable_interrupts</a> when interrupts are already disabled will have no effect interrupts-wise (but should be paired with a <a class="el" href="group__interrupt.html#ga154b837080a092ecbab0735a0254c4b4" title="Enable interrupts systemwide.">enable_interrupts</a> regardless), and in that case the paired <a class="el" href="group__interrupt.html#ga154b837080a092ecbab0735a0254c4b4" title="Enable interrupts systemwide.">enable_interrupts</a> will not enable interrupts either. In this manner, it is safe to nest calls to disable and enable interrupts. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga366982e291c08c36c7352ea07a6e096c" name="ga366982e291c08c36c7352ea07a6e096c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga366982e291c08c36c7352ea07a6e096c">&#9670;&nbsp;</a></span>interrupt_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__interrupt.html#ga366982e291c08c36c7352ea07a6e096c">interrupt_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>State of interrupts on the system. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga366982e291c08c36c7352ea07a6e096ca8391f9b3514597a92d66f4ec813bbe22" name="gga366982e291c08c36c7352ea07a6e096ca8391f9b3514597a92d66f4ec813bbe22"></a>INTERRUPTS_UNINITIALIZED&#160;</td><td class="fielddoc"><p >Interrupt controller has not been initialized. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga366982e291c08c36c7352ea07a6e096ca199b2924f37a683a3dfcae49aac28b67" name="gga366982e291c08c36c7352ea07a6e096ca199b2924f37a683a3dfcae49aac28b67"></a>INTERRUPTS_DISABLED&#160;</td><td class="fielddoc"><p >Interrupts are currently disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga366982e291c08c36c7352ea07a6e096ca63f9f656dbca41f104246bcb920cc110" name="gga366982e291c08c36c7352ea07a6e096ca63f9f656dbca41f104246bcb920cc110"></a>INTERRUPTS_ENABLED&#160;</td><td class="fielddoc"><p >Interrupts are currently enabled. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga35d016d7a4cff493528719125cf54e8d" name="ga35d016d7a4cff493528719125cf54e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35d016d7a4cff493528719125cf54e8d">&#9670;&nbsp;</a></span>__MI_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __MI_handler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle an MI interrupt. </p>
<dl class="section note"><dt>Note</dt><dd>This function handles most of the interrupts on the system as they come through the MI. </dd></dl>

</div>
</div>
<a id="ga2d2950dd0d587a88e65537694b721544" name="ga2d2950dd0d587a88e65537694b721544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d2950dd0d587a88e65537694b721544">&#9670;&nbsp;</a></span>__RESET_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __RESET_handler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle a RESET (pre-NMI) interrupt. </p>
<p >Calls the handlers registered by <a class="el" href="group__interrupt.html#gaabbbbb20f064ac035492af4a8763ef44" title="Register a handler that will be called when the user presses the RESET button.">register_RESET_handler</a>. </p>

</div>
</div>
<a id="ga2351876167328732c7ff03de3c4081db" name="ga2351876167328732c7ff03de3c4081db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2351876167328732c7ff03de3c4081db">&#9670;&nbsp;</a></span>register_AI_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void register_AI_handler </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an AI callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function to call when an AI interrupt occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga05ed635fdfe7b72490e6bca3d82a9844" name="ga05ed635fdfe7b72490e6bca3d82a9844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05ed635fdfe7b72490e6bca3d82a9844">&#9670;&nbsp;</a></span>unregister_AI_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unregister_AI_handler </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister an AI callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function that should no longer be called on AI interrupts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab3d1ab2fc7617f717482d0a8896372ab" name="gab3d1ab2fc7617f717482d0a8896372ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3d1ab2fc7617f717482d0a8896372ab">&#9670;&nbsp;</a></span>register_VI_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void register_VI_handler </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a VI callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function to call when a VI interrupt occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga432eef7630772dfe5a26b2440122c379" name="ga432eef7630772dfe5a26b2440122c379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga432eef7630772dfe5a26b2440122c379">&#9670;&nbsp;</a></span>unregister_VI_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unregister_VI_handler </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a VI callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function that should no longer be called on VI interrupts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3dd3c4fb02d0c955af17793c453bbfc3" name="ga3dd3c4fb02d0c955af17793c453bbfc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dd3c4fb02d0c955af17793c453bbfc3">&#9670;&nbsp;</a></span>register_PI_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void register_PI_handler </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a PI callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function to call when a PI interrupt occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7d6944493768b6d604359d0cdbe5bed4" name="ga7d6944493768b6d604359d0cdbe5bed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d6944493768b6d604359d0cdbe5bed4">&#9670;&nbsp;</a></span>unregister_PI_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unregister_PI_handler </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unegister a PI callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function that should no longer be called on PI interrupts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf41859f72b17670b89d7a117721f599f" name="gaf41859f72b17670b89d7a117721f599f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf41859f72b17670b89d7a117721f599f">&#9670;&nbsp;</a></span>register_DP_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void register_DP_handler </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a DP callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function to call when a DP interrupt occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga576a9619c9c5e42863664ed1dcbb7d11" name="ga576a9619c9c5e42863664ed1dcbb7d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga576a9619c9c5e42863664ed1dcbb7d11">&#9670;&nbsp;</a></span>unregister_DP_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unregister_DP_handler </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a DP callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function that should no longer be called on DP interrupts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae2ed676471062e227ad17ac859b22163" name="gae2ed676471062e227ad17ac859b22163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2ed676471062e227ad17ac859b22163">&#9670;&nbsp;</a></span>register_SI_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void register_SI_handler </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a SI callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function to call when a SI interrupt occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga082b7cf2be05e8d07404572f0d5a96b0" name="ga082b7cf2be05e8d07404572f0d5a96b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga082b7cf2be05e8d07404572f0d5a96b0">&#9670;&nbsp;</a></span>unregister_SI_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unregister_SI_handler </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unegister a SI callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function that should no longer be called on SI interrupts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf3079522044b52381718fc0f7348879e" name="gaf3079522044b52381718fc0f7348879e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3079522044b52381718fc0f7348879e">&#9670;&nbsp;</a></span>register_SP_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void register_SP_handler </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a SP callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function to call when a SP interrupt occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad3983fa9ec9de4022655d4153b39bead" name="gad3983fa9ec9de4022655d4153b39bead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3983fa9ec9de4022655d4153b39bead">&#9670;&nbsp;</a></span>unregister_SP_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unregister_SP_handler </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unegister a SP callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function that should no longer be called on SP interrupts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d5470e13ad8f649ba02b833630d6abf" name="ga9d5470e13ad8f649ba02b833630d6abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d5470e13ad8f649ba02b833630d6abf">&#9670;&nbsp;</a></span>register_TI_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void register_TI_handler </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a timer callback. </p>
<p >The callback will be used when the timer interrupt is triggered by the CPU. This happens when the COP0 COUNT register reaches the same value of the COP0 COMPARE register.</p>
<p >This function is useful only if you want to do your own low level programming of the internal CPU timer and handle the interrupt yourself. In this case, also remember to activate the timer interrupt using <a class="el" href="group__interrupt.html#ga67483ed4435081b227aa799465cb7436" title="Enable or disable the timer interrupt.">set_TI_interrupt</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If you use the timer library (<a class="el" href="group__timer.html#ga7b8ab79df77b57475a5494f5f81c3bd9" title="Initialize the timer subsystem.">timer_init</a> and <a class="el" href="group__timer.html#ga62dc88d941d6790a7427371df59d1eeb" title="Create a new timer and add to list.">new_timer</a>), you do not need to call this function, as timer interrupt are already handled by the timer library.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function to call when a timer interrupt occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1cc1089f8fe22245df63d22f314a95d6" name="ga1cc1089f8fe22245df63d22f314a95d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cc1089f8fe22245df63d22f314a95d6">&#9670;&nbsp;</a></span>unregister_TI_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unregister_TI_handler </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a timer callback. </p>
<dl class="section note"><dt>Note</dt><dd>If you use the timer library (<a class="el" href="group__timer.html#ga7b8ab79df77b57475a5494f5f81c3bd9" title="Initialize the timer subsystem.">timer_init</a> and <a class="el" href="group__timer.html#ga62dc88d941d6790a7427371df59d1eeb" title="Create a new timer and add to list.">new_timer</a>), you do not need to call this function, as timer interrupt are already handled by the timer library.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function that should no longer be called on timer interrupts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0bb059c6f6872f28fec2a819541279f4" name="ga0bb059c6f6872f28fec2a819541279f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bb059c6f6872f28fec2a819541279f4">&#9670;&nbsp;</a></span>register_CART_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void register_CART_handler </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a CART interrupt callback. </p>
<p >The callback will be called when a CART interrupt is triggered. CART interrupts are interrupts triggered by devices attached to the PI bus (aka CART bus), for instance the 64DD, or the modem cassette.</p>
<p >CART interrupts are disabled by default in libdragon. Use <a class="el" href="group__interrupt.html#gac7ddaefc83763af0e97886beb7600d8b" title="Enable or disable the CART interrupt.">set_CART_interrupt</a> to enable/disable them.</p>
<p >Notice that there is no generic way to acknowledge those interrupts, so if you activate CART interrupts, make also sure to register an handler that acknowledge them, otherwise the interrupt will deadlock the console.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function that should no longer be called on CART interrupts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7f0506a6313156207431898c0fb400ec" name="ga7f0506a6313156207431898c0fb400ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f0506a6313156207431898c0fb400ec">&#9670;&nbsp;</a></span>unregister_CART_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unregister_CART_handler </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a CART interrupt callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function that should no longer be called on CART interrupts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaabbbbb20f064ac035492af4a8763ef44" name="gaabbbbb20f064ac035492af4a8763ef44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabbbbb20f064ac035492af4a8763ef44">&#9670;&nbsp;</a></span>register_RESET_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void register_RESET_handler </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a handler that will be called when the user presses the RESET button. </p>
<p >The N64 sends an interrupt when the RESET button is pressed, and then actually resets the console after about ~500ms (but less on some models, see <a class="el" href="interrupt_8h.html#a32eeb0dea6b0c382ea7bb73cdd56b521" title="Guaranteed length of the reset time.">RESET_TIME_LENGTH</a>).</p>
<p >Registering a handler can be used to perform a clean reset. Technically, at the hardware level, it is important that the RCP is completely idle when the reset happens, or it might freeze and require a power-cycle to unfreeze. This means that any I/O, audio, video activity must cease before <a class="el" href="interrupt_8h.html#a32eeb0dea6b0c382ea7bb73cdd56b521" title="Guaranteed length of the reset time.">RESET_TIME_LENGTH</a> has elapsed.</p>
<p >This entry point can be used by the game code to basically halts itself and stops issuing commands. Libdragon itself will register handlers to halt internal modules so to provide a basic good reset experience.</p>
<p >Handlers can use <a class="el" href="group__interrupt.html#ga288a573e9c25f474c0e71cfcde6f388a" title="Check whether the RESET button was pressed and how long we are into the reset process.">exception_reset_time</a> to read how much has passed since the RESET button was pressed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Callback to invoke when the reset button is pressed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Reset handlers are called under interrupt. </dd></dl>

</div>
</div>
<a id="ga2b29ebe8db68cdbee591e8d15693cb5f" name="ga2b29ebe8db68cdbee591e8d15693cb5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b29ebe8db68cdbee591e8d15693cb5f">&#9670;&nbsp;</a></span>unregister_RESET_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unregister_RESET_handler </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a RESET interrupt callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function that should no longer be called on RESET interrupts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga87288d9e8d2c178572957295ff64ec40" name="ga87288d9e8d2c178572957295ff64ec40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87288d9e8d2c178572957295ff64ec40">&#9670;&nbsp;</a></span>set_AI_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_AI_interrupt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>active</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the AI interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">active</td><td>Flag to specify whether the AI interrupt should be active </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf53fd03f791d5a936e7db39f5c7959c1" name="gaf53fd03f791d5a936e7db39f5c7959c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf53fd03f791d5a936e7db39f5c7959c1">&#9670;&nbsp;</a></span>set_VI_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_VI_interrupt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>active</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the VI interrupt. </p>
<p >The VI interrupt is generated when the VI begins displaying a specific line of the display output. The line number configured always refers to the final TV output, so it should be either in the range 0..524 (NTSC) or 0..624 (PAL). The vblank happens at the beginning of the display period, in range 0..33 (NTSC) or 0..43 (PAL). A common value used to trigger the interrupt at the beginning of the vblank is 2.</p>
<p >In non-interlaced modes, the VI only draws on even lines, so configuring the interrupt on an odd line causes the interrupt to never trigger. In interlace modes, instead, the VI alternates between even lines and odd lines, so any specific line will trigger an interrupt only every other frame. If you need an interrupt every frame in interlaced mode, you will need to reconfigure the interrupt every frame, alternating between an odd and an even number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">active</td><td>Flag to specify whether the VI interrupt should be active </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>The vertical line that causes this interrupt to fire. Ignored when setting the interrupt inactive. This line number refers to the lines in the TV output, and is unrelated to the current resolution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6a5ec9c8b19060b6d4c7126cc670cf37" name="ga6a5ec9c8b19060b6d4c7126cc670cf37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a5ec9c8b19060b6d4c7126cc670cf37">&#9670;&nbsp;</a></span>set_PI_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_PI_interrupt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>active</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the PI interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">active</td><td>Flag to specify whether the PI interrupt should be active </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad0b3939ccf8c8eff2289c08a75cbc624" name="gad0b3939ccf8c8eff2289c08a75cbc624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0b3939ccf8c8eff2289c08a75cbc624">&#9670;&nbsp;</a></span>set_DP_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_DP_interrupt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>active</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the DP interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">active</td><td>Flag to specify whether the DP interrupt should be active </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2852664ce3950d66868cf39d8d633d62" name="ga2852664ce3950d66868cf39d8d633d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2852664ce3950d66868cf39d8d633d62">&#9670;&nbsp;</a></span>set_SI_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_SI_interrupt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>active</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the SI interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">active</td><td>Flag to specify whether the SI interrupt should be active </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga24c9ae3233fc77e0f6a1a22843c88298" name="ga24c9ae3233fc77e0f6a1a22843c88298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24c9ae3233fc77e0f6a1a22843c88298">&#9670;&nbsp;</a></span>set_SP_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_SP_interrupt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>active</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the SP interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">active</td><td>Flag to specify whether the SP interrupt should be active </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga67483ed4435081b227aa799465cb7436" name="ga67483ed4435081b227aa799465cb7436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67483ed4435081b227aa799465cb7436">&#9670;&nbsp;</a></span>set_TI_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_TI_interrupt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>active</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the timer interrupt. </p>
<dl class="section note"><dt>Note</dt><dd>If you use the timer library (<a class="el" href="group__timer.html#ga7b8ab79df77b57475a5494f5f81c3bd9" title="Initialize the timer subsystem.">timer_init</a> and <a class="el" href="group__timer.html#ga62dc88d941d6790a7427371df59d1eeb" title="Create a new timer and add to list.">new_timer</a>), you do not need to call this function, as timer interrupt is already handled by the timer library.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">active</td><td>Flag to specify whether the timer interrupt should be active</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt.html#ga9d5470e13ad8f649ba02b833630d6abf" title="Register a timer callback.">register_TI_handler</a> </dd></dl>

</div>
</div>
<a id="gac7ddaefc83763af0e97886beb7600d8b" name="gac7ddaefc83763af0e97886beb7600d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7ddaefc83763af0e97886beb7600d8b">&#9670;&nbsp;</a></span>set_CART_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_CART_interrupt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>active</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the CART interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">active</td><td>Flag to specify whether the CART interrupt should be active</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt.html#ga0bb059c6f6872f28fec2a819541279f4" title="Register a CART interrupt callback.">register_CART_handler</a> </dd></dl>

</div>
</div>
<a id="gadcf484e0e3594849dfcaea7e5c69ffe7" name="gadcf484e0e3594849dfcaea7e5c69ffe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcf484e0e3594849dfcaea7e5c69ffe7">&#9670;&nbsp;</a></span>set_RESET_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_RESET_interrupt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>active</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the RESET interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">active</td><td>Flag to specify whether the RESET interrupt should be active</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>RESET interrupt is active by default.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt.html#gaabbbbb20f064ac035492af4a8763ef44" title="Register a handler that will be called when the user presses the RESET button.">register_RESET_handler</a> </dd></dl>

</div>
</div>
<a id="ga52651bf1923b2c97e8b4da0ac6b99fdb" name="ga52651bf1923b2c97e8b4da0ac6b99fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52651bf1923b2c97e8b4da0ac6b99fdb">&#9670;&nbsp;</a></span>disable_interrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void disable_interrupts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable interrupts systemwide. </p>
<dl class="section note"><dt>Note</dt><dd>If interrupts are already disabled on the system or interrupts have not been initialized, this function will not modify the system state. </dd></dl>

</div>
</div>
<a id="ga154b837080a092ecbab0735a0254c4b4" name="ga154b837080a092ecbab0735a0254c4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga154b837080a092ecbab0735a0254c4b4">&#9670;&nbsp;</a></span>enable_interrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void enable_interrupts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable interrupts systemwide. </p>
<dl class="section note"><dt>Note</dt><dd>If this is called inside a nested disable call, it will have no effect on the system. Therefore it is safe to nest disable/enable calls. After the least nested enable call, systemwide interrupts will be reenabled. </dd></dl>

</div>
</div>
<a id="gaf84369f06d965c3fdba355cad7e71e89" name="gaf84369f06d965c3fdba355cad7e71e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf84369f06d965c3fdba355cad7e71e89">&#9670;&nbsp;</a></span>get_interrupts_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__interrupt.html#ga366982e291c08c36c7352ea07a6e096c">interrupt_state_t</a> get_interrupts_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current state of interrupts. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">INTERRUPTS_UNINITIALIZED</td><td>if the interrupt system has not been initialized yet. </td></tr>
    <tr><td class="paramname">INTERRUPTS_DISABLED</td><td>if interrupts have been disabled. </td></tr>
    <tr><td class="paramname">INTERRUPTS_ENABLED</td><td>if interrupts are currently enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga288a573e9c25f474c0e71cfcde6f388a" name="ga288a573e9c25f474c0e71cfcde6f388a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga288a573e9c25f474c0e71cfcde6f388a">&#9670;&nbsp;</a></span>exception_reset_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t exception_reset_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the RESET button was pressed and how long we are into the reset process. </p>
<p >This function returns how many ticks have elapsed since the user has pressed the RESET button, or 0 if the user has not pressed it.</p>
<p >It can be used by user code to perform actions during the RESET process (see <a class="el" href="group__interrupt.html#gaabbbbb20f064ac035492af4a8763ef44" title="Register a handler that will be called when the user presses the RESET button.">register_RESET_handler</a>). It is also possible to simply poll this value to check at any time if the button has been pressed or not.</p>
<p >The reset process takes about 500ms between the user pressing the RESET button and the CPU being actually reset, though on some consoles it seems to be much less. See <a class="el" href="interrupt_8h.html#a32eeb0dea6b0c382ea7bb73cdd56b521" title="Guaranteed length of the reset time.">RESET_TIME_LENGTH</a> for more information. For the broadest compatibility, please use <a class="el" href="interrupt_8h.html#a32eeb0dea6b0c382ea7bb73cdd56b521" title="Guaranteed length of the reset time.">RESET_TIME_LENGTH</a> to implement the reset logic.</p>
<p >Notice also that the reset process is initiated when the user presses the button, but the reset will not happen until the user releases the button. So keeping the button pressed is a good way to check if the application actually winds down correctly.</p>
<dl class="section return"><dt>Returns</dt><dd>Ticks elapsed since RESET button was pressed, or 0 if the RESET button was not pressed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt.html#gaabbbbb20f064ac035492af4a8763ef44" title="Register a handler that will be called when the user presses the RESET button.">register_RESET_handler</a> </dd>
<dd>
<a class="el" href="interrupt_8h.html#a32eeb0dea6b0c382ea7bb73cdd56b521" title="Guaranteed length of the reset time.">RESET_TIME_LENGTH</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 5 2024 19:06:52 for libdragon by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
