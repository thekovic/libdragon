<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libdragon: RDPQ: Hardware-accelerated drawing API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo2.png"/></td>
  <td id="projectalign">
   <div id="projectname">libdragon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a>  </div>
  <div class="headertitle"><div class="title">RDPQ: Hardware-accelerated drawing API<div class="ingroups"><a class="el" href="group__libdragon.html">libdragon</a> &raquo; <a class="el" href="group__display.html">Display Subsystem</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Interface to the RDP (graphics hardware) for 2D/3D rasterization.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:rdpq_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdpq_8h.html">rdpq.h</a></td></tr>
<tr class="memdesc:rdpq_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">RDP Command queue. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rdpq__rect_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdpq__rect_8h.html">rdpq_rect.h</a></td></tr>
<tr class="memdesc:rdpq__rect_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">RDP Command queue. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rdpq__sprite_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdpq__sprite_8h.html">rdpq_sprite.h</a></td></tr>
<tr class="memdesc:rdpq__sprite_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">RDP Command queue: high-level sprite loading and blitting. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rdpq__tex_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdpq__tex_8h.html">rdpq_tex.h</a></td></tr>
<tr class="memdesc:rdpq__tex_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">RDP Command queue: high-level texture/surface loading and blitting. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rdpq_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdpq_8h.html">rdpq.h</a></td></tr>
<tr class="memdesc:rdpq_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">RDP Command queue. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Interface to the RDP (graphics hardware) for 2D/3D rasterization. </p>
<p >The RDPQ ("RDP command queue") is a library that allows to interface with the RDP ("Reality Display Processor"), the GPU on the N64, through the RSP.</p>
<p >This library is quite vast because RDP is a complex chip to program and full of quirks. Moreover, the needs for 2D vs 3D are quite different, and the library copes with both. An important effort has been made to make this library "just work".</p>
<p >Since the API is wide, the library is split in several header files. Make sure to read them all to have a general overview:</p>
<ul>
<li><a class="el" href="rdpq_8h.html" title="RDP Command queue.">rdpq.h</a>: General low-level RDP command generation.</li>
<li><a class="el" href="rdpq__tri_8h_source.html">rdpq_tri.h</a>: Low-level screen-space triangle drawing API.</li>
<li><a class="el" href="rdpq__rect_8h.html" title="RDP Command queue.">rdpq_rect.h</a>: Low-level screen-space rectangle drawing API.</li>
<li><a class="el" href="rdpq__attach_8h.html" title="RDP Command queue: surface attachment API.">rdpq_attach.h</a>: Attachment API (optional), to simplify configuring the render target</li>
<li><a class="el" href="rdpq__mode_8h.html" title="RDP Command queue: mode setting.">rdpq_mode.h</a>: Mode API (optional), to simplify configuring the render modes</li>
<li><a class="el" href="rdpq__tex_8h.html" title="RDP Command queue: high-level texture/surface loading and blitting.">rdpq_tex.h</a>: Texture API (optional), to simplify uploading to TMEM and blitting 2D surfaces</li>
<li><a class="el" href="rdpq__sprite_8h.html" title="RDP Command queue: high-level sprite loading and blitting.">rdpq_sprite.h</a>: Sprite API (optional), to simplify uploading to TMEM and blitting sprites</li>
<li><a class="el" href="rdpq__debug_8h.html" title="RDP Command queue: debugging helpers.">rdpq_debug.h</a>: Debugging API (optional), to help catching bugs.</li>
</ul>
<h2><a class="anchor" id="autotoc_md34"></a>
Goals of this library</h2>
<p >This library is meant to be used directly for two tasks:</p>
<ul>
<li>2D hardware-assisted rasterization: drawing tiles, sprites, text.</li>
<li>3D rasterization of triangles computed on the CPU. This is mostly the case if you are porting a 3D engine that runs T&amp;L on the CPU but you want to draw triangles using RDP.</li>
</ul>
<p >For a full 3D project, libdragon offers a full 3D API via the OpenGL API (see gl.h); OpenGL internally uses rdpq, but it is unlikely that you will need to call rdpq directly when you are using OpenGL.</p>
<h2><a class="anchor" id="autotoc_md35"></a>
Architecture and rationale</h2>
<p >Normally, RDP commands are generated by both the CPU and the RSP. The normal split is that CPU is in charge of render mode changes (eg: loading textures, defining the alpha blending behavior, etc.), while the RSP executes a full T&amp;L pipeline which terminates with the generation of RDP triangle primitives.</p>
<p >This library allows the CPU to enqueue RDP commands. It covers the full RDP command set, including triangles. Even if for RDP commands generated by CPU, the RSP is involved: in fact, this library is a rspq overlay (see <a class="el" href="rspq_8h.html" title="RSP Command queue.">rspq.h</a>). All RDP commands are enqueued in the main RSP command queue, and they are sent to the RDP by the RSP.</p>
<p >There are two main reasons for this design (rather than letting the CPU directly send the commands to the RDP):</p>
<ul>
<li>Given that CPU and RSP usually work in parallel (with as few as possible syncing points), it is necessary to make sure that the CPU is able to schedule RDP commands that will be executed in the right order with respect to commands generated by RSP. This is easy to do if CPU-generated RDP commands always go through RSP in main command queue.</li>
<li>Most of the commands are sent unchanged to the RDP (we call them "passthrough"). Some commands, instead, are manipulated by the RSP and changed before they hit the RDP (we call these "fixups"). This is done to achieve a saner semantic for the programmer, hiding a few dark corners of the RDP hardware.</li>
</ul>
<p >The documentation of the public API of this library describes the final behavior of each rdpq command, without explicitly mentioning whether it is obtained via fixups or not. For more information on these, see the documentation of <a class="el" href="rdpq_8c.html" title="RDP Command queue.">rdpq.c</a>, which gives an overview of many implementation details.</p>
<h2><a class="anchor" id="autotoc_md36"></a>
Render modes</h2>
<p >The most complicated part of programming RDP is getting the correct render mode configuration. At the lowest level (hardware commands), this can be done via two functions: <a class="el" href="rdpq_8h.html#af8d2a9819765d53a5128f279a7ea0ccb" title="Low-level function to set the rendering mode register.">rdpq_set_other_modes_raw</a> (that maps to the RDP command <code>SET_OTHER_MODES</code>, usually shortened as "SOM") and <a class="el" href="rdpq_8h.html#a47aa5fe237da5c43e2bfbf2527af606f" title="Low-level function to change the RDP combiner.">rdpq_set_combiner_raw</a> (that maps to the RDP command <code>SET_COMBINE</code>). These functions are meant for programmers already familiar with the RDP hardware, and allow you to manipulate configurations freely.</p>
<p >To help with partial SOM changes, rdpq also offers <a class="el" href="rdpq_8h.html#a63486735278da233229c6cf5fb3b3aaf" title="Low-level function to partly change the rendering mode register.">rdpq_change_other_modes_raw</a> that allows to change only some bits of the SOM state. This is done by tracking the current SOM state (within the RSP) so that a partial update can be sent. It is useful to make programming more modular, so that for instance a portion of code can temporarily enable (eg.) fogging, without having to restate the full render mode.</p>
<p >Alternatively, rdpq offers a higher level render mode API, which is hopefully clearer to understand and more accessible, that tries to hide some of the most common pitfalls. This API can be found in the <a class="el" href="rdpq__mode_8h.html" title="RDP Command queue: mode setting.">rdpq_mode.h</a> file. It is possible to switch from this the higher level API to the lower level one at any time in the code with no overhead, so that it can be adopted wherever it is a good fit, falling back to lower level programming if/when necessary.</p>
<p >Beginners of RDP programming are strongly encouraged to use <a class="el" href="rdpq__mode_8h.html" title="RDP Command queue: mode setting.">rdpq_mode.h</a>, and only later dive into lower-level RDP programming, if necessary.</p>
<h2><a class="anchor" id="autotoc_md37"></a>
Blocks and address lookups</h2>
<p >Being a RSPQ overlay, it is possible to record rdpq commands in blocks (via <a class="el" href="rspq_8h.html#a41f292fc1f7b261f84c55fc356f86acf" title="Begin creating a new block.">rspq_block_begin</a> / <a class="el" href="rspq_8h.html#a81339d69802148a09829d1c6d9a9f9f6" title="Finish creating a block.">rspq_block_end</a>, like for any other overlay), to quickly replay them with zero CPU time.</p>
<p >rdpq has also some special memory-bandwidth optimizations that are used when commands are compiled into blocks (for more details, see documentation of <a class="el" href="rdpq_8c.html" title="RDP Command queue.">rdpq.c</a>). In general, it is advised to use blocks whenever possible, especially in case of a sequence of 3 or more rdpq function calls.</p>
<p >TO BE COMPLETED....</p>
<h2><a class="anchor" id="autotoc_md38"></a>
Debugging: tracer and validator</h2>
<p >To help writing correct code, rdpq comes with two very important features:</p>
<ul>
<li>A command tracer with disassembler. rdpq is able to intercept all commands sent to RDP (including commands assembled directly by third-party rspq overlays), and log them via <a class="el" href="debug_8h.html#aa3e8be416ef1525cfd3230204b56d184" title="Write a message to the debugging channel.">debugf</a>. The log includes a full disassembly of the commands, to help readability.</li>
<li>A validator. rdpq can re-interpret all commands sent to RDP and validate that they are correct, not only syntactically but also semantically. It is extremely easy to make mistakes in programming RDP by setting wrong mode flags or forgetting to configure a register, so the validator tries to help by flagging potential problems. All validation errors and warnings are sent via <a class="el" href="debug_8h.html#aa3e8be416ef1525cfd3230204b56d184" title="Write a message to the debugging channel.">debugf</a>.</li>
</ul>
<p >To initialize the debugging engine, call <a class="el" href="rdpq__debug_8h.html#a55c7e558e4673c0d498a6dc2be1c0792" title="Initialize the RDPQ debugging engine.">rdpq_debug_start</a> just after <a class="el" href="rdpq_8h.html#a568b75da730c69457404cf6dd0c1da15" title="Initialize the RDPQ library.">rdpq_init</a> (or as early as possible). This will start intercepting and validating all commands sent to RDP, showing validation errors on the debug spew.</p>
<p >To see a log of RDP commands, call <a class="el" href="rdpq__debug_8h.html#a803828ee30e0abcd321e5dbc362e7d0d" title="Show a full log of all the RDP commands.">rdpq_debug_log</a> passing true or false. You can activate/deactivate logging around portions of code that you want to analyze, as keeping the log active for a whole frame can produce too many information. </p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
